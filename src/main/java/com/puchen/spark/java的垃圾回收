垃圾的标记算法
    概念：简单的说就是内存中已经不再被使用到的空间就是垃圾
    引用计数法:
        1:给对象添加一个引用计数器
        2：有点：实现简单，效率高
        3：缺点：不能解决对象之间循环引用的问题
    根搜索方法(可达性分析算法)
        1 从根节点向下搜索对象节点，所搜走过的路径称为引用链，
            当一个对象到根之间没有连通的话，则该对象不可用
    Stop-The-World
        STW是java中一种全局暂停的现象，多半由于full GC引起。所谓全局停顿，就是所有的Java代码停止运行，
      native代码可以执行，但是不能和jvm交互。
        去危害就是服务长时间通知，没有响应;对于HA系统可能引起主备切换，
        主备切换的时候是集群最脆弱的时候，一般情况下不希望发生主备切换，严重危害生产环境
        ##串行，并行，并发收集器（各有各的优缺点）
        #1：串行收集：只有一个线程，GC单线程内存回收，会暂停所有的用户线程
        #2：并行收集：多cpu的情况，多个GC线程并发工作，此时用户线程是暂停的
        #3：并发收集器：对线程的垃圾回收，多个线程和GC线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程  HA集群系统，购物网站
        #4：Seral是串行的，Parallel是并行的，CMS是并发的

    垃圾回收算法 ------标记清除法（Mark Sweep）
        算法分为标记和清楚两个阶段，先标记出要回收的对象，然后统一回收这些对象。
        1优点是简单
        2缺点是：
            效率不高，标记和清楚的效率都不高
            标记清除后会产生大量不连续的内存碎片，从而导致在分配大对象是触发GC
    垃圾回收算法----复制算法
        把内存分为两块完全相同的区域，每次使用其中一块，当一块使用完了，
        就把这块还存活的对象拷贝到另外一块，然后把这块清除掉
        1优点是：实现简单，运行效率高效，不用考虑内存碎片的问题
        2缺点是：内存浪费大，只能使用一半
        3JVM实际实现中，是将内存分为一块较大的Eden区和两块较小的Survivor空间，每次使用Eden和
            一块Servivor，回收时，把存活的对象复制到另外一块Survivor
        4HotSpot默认的Eden和survivor比是8:1  也就是每次都能用90%新生代空间
        5如果空间不够，就要依赖老年代进行分配担保，把放不下的对象直接进入老年代
    标记收集算法-------标记整理算法(Mark-Compact)
        由于复制算法在存活对象比较多的时候，效率较低，且有空间浪费，因此老年代一般不会选用复制算法，
            老年代多选用标记整理算法
        标记过程跟标记清除一样，但是后续不是直接清除可回收对象，而是让所有存活对象都是一端移动，然后
            直接清除边界意外的内存

串行的收集器（Serial收集器）使用在一个CPU的时候
    1是一个单线程的收集器  在垃圾收集是 会Stop-The-world
    2有点是简单 对于单cpu  有没有多线程的交互开线 可能更改线  默认是Client模式下的新生代收集器
    3使用-XX:+UserSerialGC来开启
        会使用：Serial + Serial Old的收集器组合
    4新生代使用复制算法 老年代使用标记-整理算法
ParNew收集器（并行）
    1使用多想成进行卡机回收  在垃圾收集时  会Stop-the-World
    2在并发能力好的CPU环境里  它停顿的时间要比串行收集器端 但对于单CUO或并发能力较弱的CPU
        由于多线程的交互开销 可能比串行回收器更差
    3是Server模式下首选的新生代收集器 且能和CMS收集器配合使用
    4使用-XX:+UserParNewGC来开启
        会使用：ParNew+Serial Old的收集器组合
    5-XX:ParallelGCThreads:指定线程数  最好与CPU数量一致
    6新生代使用复制算法，老年代采用标记-整理算法
CMS收集器（并发标记清除）收集器  （最大的优势 不需要停顿用户线程）
    1分为四个阶段
        初始标记：只标记GC Roots能直接关联到的对象
        并发标记: 进行GC Roots Tracing的过程
        重新标记：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象
        并发清除：并发回收垃圾对象
    2在初始标记和重新标记两个阶段还是会发生Stop-the-World
    3使用标记清除算法，也是一个使用多线程并发收集的垃圾收集器
    4最后的重置线程 指的是清空跟收集相关的数据并重置 为下一次收集做准备








