分组
	实际上分组组件  有作用 但是分组位置不对
	现在看到的效果 排序在前  分组在后
	实际想要看到的效果  是分好组之后进行排序
	在map到reduce过程中  会默认的先进行排序  再进行分组
	如果想要这个结果：排序阶段将分组字段纳入 排序范围
	排序的字段：先按课程  再按分数

	当基友分组又有排序的时候：排序在前分组在后
		排序字段一定要包含分组字段
		实际上的分组仅仅时间gmap输出的结果  相邻的进行比较  仅仅会比较前一条数据和后一条数据
		如果相同返回为1组  如果不相同重新划分分组
		如果想要分组一定要能保证分组字段的数据在相邻的位置
		
		排序:A B C
		分组:D F
		分组实际排序字段： D F A B C 为了保证相同的分组数据相邻
		分组的字段：D F
		实际中分组的字段一定是排序字段的前几个
			排序： A B C
			分组：A AB ABC		

reduce函数中的两个坑：
	1 reduce中values  Iterable<IntWritable> values  只能循环遍历一次  指针的 每次训话遍历完成指针都会移动到最后一个e
	2  迭代器中所有公用的对象公用同一个地址
	
	
Reduce端的join过程
	保证在map端进行文件读取的时候一次性两个表的数据，需要对两个表的数据进行区分
	将两个表放在同一个目录下
	map端做的事情：发送数据的时候需要打标记
		读取两个表中的数据  进行切分  发送
		key:公共字段  关联字段  pid
		value:剩下的  需要有标记  标记数据的来源
	reduce端
		接受过来，判断是来自于哪个表的数据进行拼接
	在mapper方法中
		在maptask执行之前调用一次 并且一个maptask只会调用一次
		setup(context);  //先调用   setup中通常会帮助map中初始化一写变量或者资源  主要目的减少变量或者属性的初始化次数 进而提神程序的性能 
	    try {
	      while (context.nextKeyValue()) {
	        map(context.getCurrentKey(), context.getCurrentValue(), context);
	      }
	    } finally {
	      //maptask任务执行完成之后会调用一次  1个maptask
	      cleanup(context);  //最后调用  处理一些善后工作  比如说:资源关闭   
	    }
	缺陷：
		1 reduce的并行度问题  0.95*datenode节点的个数  并行度不高  性能不高
		2   容器是又性能问题  不提倡 reduce接受到的数据  可能会很大
		3 reduceTask容易产生数据倾斜  没有设置默认为1个  假设我们设置多个reducetask 根据分区规则  默认hash
		  	key:关联条件   数据不平衡容易造成reduce数据倾斜   就是每个reduetask的分工不均  非常影响性能的
		  	没有合理利用集群资源
		  	在真是的生产过程中 要尽量避免数据倾斜  最好的做法：将分区设计的足够完美   难度比较大  一般情况下不建议使用
		  	
		  	如果能够在map端就完成join的过程

Map端的join过程
	为了提升map端的性能  我们的是将小表的数据加到到每个运行maptask的内存中 
	如果小表被加载到了内存中，我们每次在map端只需要读取大表，当读取到大表中的每一行数据，可以之间和内存中的小表进行关联，那么这个时候
	我们仅仅需要map就可以完成join操作了
	
	怎么把小表加载到内存中？
	job.addCacheArchive(uri);   //将指定的文件加载到缓存中
	map端怎么读取到缓存中的数据?
		想要在java中使用缓存中的数据   缓存中的数据必须封装到容器中  为了保证mao函数中可以匹配到缓存中的数据     这个封装的过程应该是在map函数之前
	这种缓存的方式只能大jar到缓存中去执行
	
	缓存加载的时候  本地
	加载缓存的时候拉去到本地的文件:
		/home/hadoop/data/hadoopdata/nm-local-dir/filecache/10
	
	map join的方式：大*小表
		因为有一个表需要加载到内存中  注定加载到内存中的表不能过大   不要超过256M  hive中默认的
		
	大表*大表
		1）reduce join的搓成  解决数据倾斜的问题   合理设计分区  很难做到
		2）将其中一个大表进行切分  切分成小表   在执行大表*小表
	优点：并行度高  不存在数据倾斜  运行效率比较高
	
	优先选择map join

排序算法：
	快速排序：
		选择一个边界值：随意选择一个数组中的元素  用于表示排序的边界   数据大小的边界     左侧小于|右侧大于
		通常情况下：第一个值  中间  最后的值
		先从后往前排序
		先从后往前排序    从最后一个元素一次向前遍历和边界值进行比较   如果比边界值大  不变  如果比他小  则交换
		
		新的边界变成交换之后的位置
	归并排序：
		归 ：分            并：和
		归并排序：针对有序的多个小数据集
		归并排序两个小数组：两个小数组合并成一个有序的大数组   两个小数组都是有序的






















