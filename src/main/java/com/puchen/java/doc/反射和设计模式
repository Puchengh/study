类的概念
    描述具有一类相同特征或者行为的事物
    对象：类的一个实例化   类的具体表现形式
    Calss:用于描述所有类的类  所有的类也有共同的特性 比如:属性 方法
    Class就是反射的基础
    反射:将java类中的各个成分（属性，方法 ，构造方法）给他映射成对应的类
        将java类中的各个成分按照类进行管理
        反射是架构师必备技能  使用场景;
            JDBC   Class.forName("com.mysql.jdbc.Driver")
            JDBC   Class.forName("com.hive2.jdbc.Driver")
            JDBC   Class.forName("com.oracle.jdbc.Driver")
    反射的好处:提高了整个代码的灵活性  不需要知道细节  写框架的时候需要
    反射的写法:Class获取类的描述类：===.class文件  字节码文件  类的描述信息
        1)类名.Class 2)对象.getClass() 3)Class.forName("类的全路径名")
    文件的作用:  如果.calss文件已经被加载到内存 直接返回
                如果没有被加载到内存  则先会加载到内存中
        Constructor：构造器的描述类
        Field:属性的描述类
        Method:方法的描述类

        Class p = Test.class;
        //parameterTypes  可变参数类型
        p.getConstructor(parameterTypes)
        写法;变量类型+...+可变参数名称

    java的反射中有9中预定义类型  8中基本数据类型 和 void
        isPrimitive()  判断是否是预定义类型的
            Integer.TYPE == int.calss
        TYPE  这个方法获取包装类所包装的类的class
        数组引用数据类型
元数据:用于记录数据信息的数据

设计模式:总结出来关于一些问题的最佳的解决方法
23种设计模式: 3-4
    结构型模式: 工厂方法模式 抽象工厂模式  单例模式  建造者模式  原型模式
    行为模式:适配器模式 装饰者模式 代理模式 外观模式  桥接模式  组合模式  享元模式
    行为型模式:策略模式 模板方法模式  观察者模式  迭代子模式  责任链模式  命令模式  备忘录模式 状态模式 访问者模式 中介者模式 解释器模式

  总原则：开闭原则  对修改关闭 对扩展开放
  六大原则：
  1.单一职责原则 每个类应该实现单一的职责
  2.里氏替换原则 子类对父类的方法尽量不要重写和重载
  3.以来倒转原则  面向接口编程，依赖于抽象而不依赖与具体
  4.接口隔离原则 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分
  5.迪米特法则（最少知道原则）  一个类对自己依赖的类知道的越少越好
  6.合成复用原则  首先使用合成/聚合的方式   而不是使用继承

    单例设计模式:为了创建全局唯一的实例对象
        饿汉模式:类加载的时候就创建对象
        懒汉模式:需要的时候才创建对象
    装饰者设计模式:
        IO流 字符流
        装饰者设计模式  当你需要对某一个类的某一个功能进行增强的时候  需要使用到装饰者设计模式
        1.将要装饰的包装类作为增强类的属性
        2.需要实现增强功能
    代理模式：
        代理的主要作用就是做一些需要增强的事情
        静态代理模式是由缺陷的
            1.如果有很多个对象需要代理 那么就需要写实现很多个对象的代理类  这样的话代码臃肿  用户体现不好
            2.如果被代理对象的方法过多，每个方法就需要增强  代码不简洁  大量的重复工作
        代理模式的编写要点:
            1.和被代理对象实现相同的接口
            2.在代理类需要对被代理对象初始化
            3.需要实现和被代理对象相同的方法  并且在这个方法中核业务调用代理对象的  增强的业务增强在这里就可以了
         动态代理：（java自带的）
            可以通过用户传入的被代理对象动态生成代理对象，并且可以动态的获取目标方法  对目标方法进行增强
            1.实现一个接口 这个接口的名字叫做implements invocationhandler
            2.将代理对象作为属性传入  代理所有的类   private Object  obj;
            3.初始化这个对象的值public 类名(Object o){this.obj=o}
            4.重写invoke()方法
                参数1 object proxy   被代理对象  基本不用
                参数2 Method method  被代理对象的业务方法  反射里面描述方法的类 可以获取到方法的名称  或者直接盗用方法
                参数3 Object[] args  被代理对象业务方法的参数
              需要做的事情就是对代理对象的方法的增强
                1)增强的方法
                2)业务方法调用   Object res = method.invoke(obj,args)   参数1--对象   参数2--自带的参数
                3)增强的方法
                4)返回结果  return res;
              生成对象对象
                参数1 类加载器  被代理对象的  被代理对象.class.getClassLoader()
                参数2 接口  被代理对象.class.getInterfaces()
                参数3 代理类对象  new 代理类()
                创建代理对象  用接口类型去接收 Object proxyInstenace = Proxy.new ProxyInstance(loader,interfaces,h)
                调用方法(方法的调用看对象，向上溯源---自己没有方法想父类去寻找)
                proxyInstenace.insert(new Teacher());
    静态代理和装饰者模式有什么区别:
        装饰者模式和静态代理模式在代码上的区别，
            代码上：
                一般情况下装饰者模式的被装饰对象是通过外部传入，装饰的是一类事物 例如:这类事物只要是list就行
                    对方法名没有要求
                一般情况下静态代理模式被代理的对象初始化一般是内部创建的。代理一般代理的是一个类的对象
            功能上：
                装饰者模式：用于对被装饰者业务逻辑实现或者增强
                静态代理:代理主要用于权限控制，日志打印，错误预警等功能
    三种设计模式:
        单列设计模式  装饰者模式 动态代理模式

    常见的手写代码题目：
        冒泡排序
        快速排序---->冒泡 快排 归并
        设计模式
        hadoop编程的wordcount
        scala编程的wordcount
        spark编程的wordcount



