1.内存结构
2.垃圾回收机制
3.性能监控工具
4.性能调优案例实战
5.认识类的文件结构
6.类加载机制
7.字节码执行引擎
8.虚拟机编译以及运行时优化

RIA 富客户端  富因特网应用程序（Rich Internet Applications，RIA）利用具有很强交互性的富客户端技术来为用户提供一个更高和更全方位的网络体验。
QQ 客户端应用

Java7
    OAK 绿色环保项目  write once run where
Java8的新特性  函数式编程是技术的发展方向  而Lambda是函数式编程最基础的内容
    接口的默认方法和静态方法
    Lambda表达式和函数式编程
    Date API
    重复注解
    更好的类型推荐   在很多场景下编辑器可以推到出某个参数的数据类型，从而使得代码更为简洁
    Nashorn JavaScript引擎

Java技术体系
    java程序设计语言
    Class文件格式
    各硬件平台上的java虚拟机
    Java API   编程的接口
    第三方的Java类库

Java的平台
    Java SE--->startard edition  提供了Java的核心API
    Java EE--->Java移动端   nokia 60
    Java ME--->Web的应用

虚拟机中的一个产品
    Sun Classic VM
    Exact VM
    Sun Hotspot
    Bea JRockit
    J9
Sun Hotspot
    历史
    优势

垃圾回收
    1如何判定对象为垃圾对象
        引用计数法
        可达性分析法
    2如何回收
        回收的策略
            标记-清楚算法
            复制算法
            标记-整理算法
            分带收集算法
        常见的垃圾回收器
            Serial
            Parnew
            Cms
            G1
    3合适回收

    Java虚拟机内存管理
        线程共享区->方法区和java堆     ----执行引擎
            方法区   存储运行时常量池  已被虚拟机加载的类信息和常量，静态变量，即时编辑器编译后的代码的数据
            java堆   存储对象实例
        线程独占区->虚拟机栈  本地方法栈  程序计数器   ----本地库接口   ----->本地方法区
            虚拟机栈  存放方法运行时所需的数据  称为栈帧
            本地方法栈  为JVM所调用到的Nativa即本地方法服务
            程序计数器  记录当前线程锁执行到的字节码的标识   占用的内存空间比较少

    程序计数器：
        程序计数器是一块较小的内存空间，他可以看做是当前线程锁执行的字节码的行号指示器
        程序计数器处于线程独占区
        如果线程执行的Java方法，这个技术器记录的正式执行的虚拟机字节码指令的地址，如果正在执行的native方法，这个技术器的值为undefined
        此区域是唯一一个在java虚拟机规范中没有规定任何outofmemoryerror情况的区域
        goto 保留字  直接能够跳到某一行去
    Java虚拟机栈 先进后出 后进先出
        虚拟机栈描述的是Java方法执行的动态内存模型
        栈帧  frame  和方法的调用有关
            每个方法执行，都会创建一个栈帧，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈。动态链表，方法出口等
        局部变量表
            存放编译器可知的各种基本数据类型，引用类型，returnAddress类型大小

spark课程中的JVM
    class Loader  加载class文件 加载到运行时区里面的方法区
运行时的方法区
    栈 heap 局部变量表，a b c user  这些变量指向堆里面

    ##（重点）堆 stack 实例数据是存在堆里面的  方法区的信息是存在此处  HBase内存模型  JDK7
        年轻带  年轻带如果设置不合理  则年轻带回提前进入老年带
            Eden区  如果存满了会发生 minor GC 垃圾回收  把还存活的对象放在另外一个s区的另外一个区域
                    minor GC时时刻刻都在发生
            s1 s2(from to)
        老年带  如果年轻带垃圾回收还没有干净  则会放到老年带中去   如果存满了话  会发生full GC
            大多数的full GC  会有dtop-the-word的特点，假设运行的代码叫用户线程，GC进行回收的叫做用户线程，full GC发生会让用户线程停止，让他的工作线程开始工作 进行垃圾回收
            老年带如果满了容易发生full GC
        （非堆）永久带  64MB  这里的大小不容易设计 Hebernate 自动生成类 存在永久带里面，是的永久带不可控制
            以前的永久带，用来存放calss,method的元数据信息，但是在jdk8中已经没有，取而代之的是元空间，元空间不在
            虚拟机里面了，而是直接使用本地内存了.
        JDK8
        ##堆外存
    JVM的调优最终的目的就是防止频繁full GC的发生

    方法区 method 存了类元数据信息，类的定义，方法等信息
#######################################################################################################################################################################################################
   元空间 为什么要用元空间代替永久区
   1）类以及发放的信息比较难确定其大小，因此对应永久区的指定比较困难，大小容易导致永久带溢出，
        太大统一导致老年带溢出
   2）永久带会给GC带来不需要的复杂度，并且回收效率低
   3）Oracle可能会将hotsport和JRockit合二为一 不然前两个理由可能有点牵强

spark0.9  1.3的时候比较牛（sparkSQL）
    钨丝计划(底层的一些东西)
    1）内存  spark =》scala java  =>JVM  => 垃圾回收（各种性能就会降低）
        堆外存  如果使用堆外存就不受JVM管理了 =》 不受垃圾回收限制了
        c,c++ -->自己去管理的内存   spark也想自己去管理
        可以不操作对象，二进制数据（不需要序列化和反序列化）
    2）CPU
        code gernation
        硬编码（就是通过java scala语言去遍历数据）回去寄存器里面去数据  性能会比较高
        select count(*) from store_sales where ss_item_sk == 1000
        和
        var count = 0
        for (ss_item_sk in store_sales) {
          if (ss_item_sk == 1000) {
            count += 1
          }
        }

        Whole-stage Code Generation会sql翻译成硬编码的格式

    磁盘网络

    spark2在消耗内存和cpu的时候比spark1块10倍左右





