redis数据淘汰策略redis.conf
    Redis官方给的警告，当内存不足的时候，redis会根据配置的缓存策略淘汰部门keys,以保证写入成功,
    当无淘汰策略时或者没有找到适合淘汰的key时，redis直接返回out of memory错误
    最大缓存配置
    在redis中，允许用户设置最大使用内存大小 maxmemory 512G
redis提供六种数据淘汰策略
    volatile-lru:从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
    volatile-lfu:从已设置过期的keys中，删除一段时间内使用次数最少使用的
    volatile-ttl:从已设置过去时间的数据集中挑选最近将要过期的数据淘汰
    volatile-random:从已设置过期时间的数据集中随机选择数据淘汰
    allkeys-lru:从数据集中挑选最近最少使用的数据淘汰
    allkeys-lfu:从所有keys中  删除一段时间内使用次数最少使用的
    allkeys-random:从数据集中随机选择数据淘汰
    no-enviction(驱逐):禁止驱逐数据（不采用任何淘汰策略，即默认为此配置）,
                        针对写操作，返回错误
建议：了解redis的淘汰策略之后，在平时使用时应精良主动设置/更新key的expire时间，
        主动剔除不活跃的旧数据，有助于提升查询性能。

持久化
    RDB：是一种redis的默认持久化的机制  RDB相当于快照的方式，保存的是一种状态
    优点：
        快照保存数据极快，还原数据极快
        适用于灾难备份
    缺点:
        小内存机器不适合使用，RDB机制符合要求就会照快照
    AOF：redis意外down掉，比快照有更好的持久化， appendonly.aof文件
    产生的问题：过程细节都会保存下来.
              aof的方式使得持久化文件变得越来越大，例如我们调用incr test命令100次，
              文件中必须保存全部的100条命令，其实有99条都是多余的。

redis缓存与数据库一致性
    --1 实时同步
    对强一致要求比较高，应采用试试同步方案，即查询缓存查询不到在从DB查询，保存到缓存，
    更新缓存时，先更新数据库，在更新缓存的设置过期（建议不要去更新缓存内容，直接设置缓存过期）

    @Cacheable：查询时 使用，注意Long类型需要转换为String类型，否则会抛异常
    @CachePut：更新时使用，使用此注解，一定会从DB上查询数据
    @CacheEvict： 删除时使用
    @Caching: 组合用法
    --2 异步队列
    对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。
    --3 使用阿里的同步工具
    canan实现方式是模拟mysql salave和master的同步机制，监控DB bitlog的日志更新来出发缓存的
    更新，此种方法可以解放程序员的双手，减少工作量，但在使用时有些局限性。
    --4 采用UDF自定义函数的方式
    面对mysql的API进行编程，利用触发器进行缓存同步，但是UDF主要是C/C++语言实现，学习成本高。

Redis Cluster  集群搭建
集群中至少应该有奇数个节点，所以搭建集群最少需要3台服务器，同事每个节点至少有一个备份节点
所以最少需要创建使用6台机器，才能完成Redis Cluster集群（主节点，备份节点有redis-cluster集群确定）
